# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gSwFEefH_eEgRPNCmYIKYWAmZacWYrw9
"""

import matplotlib.pyplot as plt
import re
def unipolar_nrz_encode(binary_message, voltage_high=1, voltage_low=0, bit_duration=1):
    encoded_signal = []

    for bit in binary_message:
        if bit == '1':
            encoded_signal.extend([voltage_high] * bit_duration)
        else:
            encoded_signal.extend([voltage_low] * bit_duration)

    return encoded_signal
def nrz_L_encode(binary_message, voltage_high=1, voltage_low=-1, bit_duration=1):
    encoded_signal = []

    for bit in binary_message:
        if bit == '1':
            encoded_signal.extend([voltage_high] * bit_duration)
        else:
            encoded_signal.extend([voltage_low] * bit_duration)

    return encoded_signal
def nrz_i_encode(binary_message, voltage_high=1, voltage_low=0, bit_duration=1):
    encoded_signal = []
    current_voltage_level = voltage_high

    for bit in binary_message:
        if bit == '1':
            current_voltage_level = -current_voltage_level
        encoded_signal.extend([current_voltage_level] * bit_duration)

    return encoded_signal
def Manchester(binary_message, voltage_high=1, voltage_low=-1, bit_duration=2):
    encoded_signal = []

    for bit in binary_message:
        if bit == '1':
            encoded_signal.extend([voltage_low] * 1)
            encoded_signal.extend([voltage_high] * 1)

        else:
            encoded_signal.extend([voltage_high] * 1)
            encoded_signal.extend([voltage_low]* 1)
    return encoded_signal
def Differential_Manchester(binary_message, voltage_high=1, voltage_low=-1, bit_duration=2):
    encoded_signal = []
    current_volt = voltage_low
    for bit in binary_message:
        if bit == '1':
            current_volt = -current_volt
            encoded_signal.extend([current_volt] * 1)
            encoded_signal.extend([-current_volt] * 1)

        else:
            encoded_signal.extend([current_volt] * 1)
            encoded_signal.extend([-current_volt]* 1)
    return encoded_signal
def AMI_encoding(binary_message, voltage_high=1, voltage_low=-1, bit_duration=1):
    encoded_signal = []
    current_volt = voltage_low
    for bit in binary_message:
        if bit == '1':
            current_volt = -current_volt
            encoded_signal.extend([current_volt] * 1)


        else:
            encoded_signal.extend([0] * 1)

    return encoded_signal

def Pseudoternary_encoding(binary_message, voltage_high=1, voltage_low=-1, bit_duration=1):
    encoded_signal = []
    current_volt = voltage_low
    for bit in binary_message:
        if bit == '1':
            encoded_signal.extend([0] * 1)


        else:
          current_volt = -current_volt
          encoded_signal.extend([current_volt] * 1)


    return encoded_signal
def Scrambling_bzs(binary_message, voltage_high=1, voltage_low=-1, bit_duration=1):
    encoded_signal = []
    current_volt = voltage_low
    for bit in binary_message:
        if bit == '1' or bit == 'B':
            current_volt = -current_volt
            encoded_signal.extend([current_volt] * 1)

        elif bit == 'V':
            encoded_signal.extend([current_volt] * 1)
        else:
            encoded_signal.extend([0] * 1)


    return encoded_signal
def hdb3(binary_message, voltage_high=1, voltage_low=-1, bit_duration=1):
    encoded_signal = []
    current_volt = voltage_low
    for bit in binary_message:
        if bit == '1' or bit == 'B':
            current_volt = -current_volt
            encoded_signal.extend([current_volt] * 1)

        elif bit == 'V':
            encoded_signal.extend([current_volt] * 1)
        else:
            encoded_signal.extend([0] * 1)


    return encoded_signal
def longest_palindrome(string):
    n = len(string)

    # Create a table to store the results of subproblems
    table = [[0] * n for _ in range(n)]

    # All substrings of length 1 are palindromes
    max_length = 1
    start_index = 0
    for i in range(n):
        table[i][i] = True

    # Check for palindromes of length 2
    for i in range(n - 1):
        if string[i] == string[i + 1]:
            table[i][i + 1] = True
            max_length = 2
            start_index = i

    # Check for palindromes of length greater than 2
    for k in range(3, n + 1):
        for i in range(n - k + 1):
            j = i + k - 1
            if string[i] == string[j] and table[i + 1][j - 1]:
                table[i][j] = True
                if k > max_length:
                    max_length = k
                    start_index = i

    return string[start_index:start_index + max_length]





# Get user input
binary_message = input("Enter binary message: ")

# Get user's choice
choice = int(input("Choose an encoding method (1-9): "))

# Apply the selected encoding method
if choice == 1:
    encoded_signal = unipolar_nrz_encode(binary_message)
elif choice == 2:
    encoded_signal = nrz_L_encode(binary_message)
elif choice == 3:
    encoded_signal = nrz_i_encode(binary_message)
elif choice == 4:
    encoded_signal = Manchester(binary_message)
elif choice == 5:
    encoded_signal = Differential_Manchester(binary_message)
elif choice == 6:
    encoded_signal = AMI_encoding(binary_message)
elif choice == 7:
    encoded_signal = Pseudoternary_encoding(binary_message)
elif choice == 8:
    # Use regular expression to find eight consecutive '0's
    matches = re.findall(r'0{8}', binary_message)

    # Replace eight consecutive '0's with '000VB0VB'
    binary_message = re.sub(r'0{8}', '000VB0VB', binary_message)
    if len(matches) != 0:
        encoded_signal = Scrambling_bzs(binary_message)
elif choice == 9:
    i = 0
    count1 = 0
    result = []

    while i < len(binary_message):
        if binary_message[i] in ['1', 'B', 'V']:
            count1 += 1

        # Check if the current character and the next 3 characters are '0'
        if i + 3 < len(binary_message) and all(binary_message[j] == '0' for j in range(i, i + 4)):
            if count1 % 2 == 0:
                result.extend(['B', '0', '0', 'V'])
                count1+=2
            else:
                result.extend(['0', '0', '0', 'V'])
                count1+=1
            i += 3  # Skip the next 3 characters
        else:
            result.append(binary_message[i])

        i += 1

    # Combine the result list into a string
    result_string = ''.join(result)
    encoded_signal = hdb3(result)

# Detect the longest palindrome
longest_palindrome_str = longest_palindrome(binary_message)

# Plot the encoded signal
plt.figure(figsize=(10, 2))
plt.step(range(len(encoded_signal)), encoded_signal, where='post')
plt.title('Encoded Signal')
plt.xlabel('Time (bit periods)')
plt.ylabel('Voltage')
plt.grid(True)
plt.show()

# Print the longest palindrome
print(f"The longest palindrome in the input string is: {longest_palindrome_str}")

